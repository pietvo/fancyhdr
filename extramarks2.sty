%%
%% This is file `extramarks2.sty',
%%
%% This file may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License, either version 1.3 of this license
%% or (at your option) any later version.  The latest version of this
%% license is in:
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% and version 1.3 or later is part of all distributions of LaTeX version
%% 2005/12/01 or later.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{extramarks2}
           [2021/03/17 v0.1
                  Extra marks for LaTeX]
% Copyright (C) 2021 by Pieter van Oostrum <pieter@vanoostrum.org>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RequirePackage{expl3,xparse}
\RequirePackage{etoolbox}

\ExplSyntaxOn

% Global variables
% Sequence of define extra marks

\seq_new:N \g__extramarks_marks_seq

% Temporary box

\box_new:N \l__extramarks_temp_box

% Temporary token lists

\tl_new:N \l__extramarks_temp_tl

% Messages

\msg_new:nnn {extramarks2} {not-defined} {\token_to_str:N #1:~mark~#2~not~defined}
\msg_new:nnn {extramarks2} {already-defined} {\token_to_str:N #1:~mark~#2~already~defined}
\msg_new:nnn {extramarks2} {cannot-patch} {Patch \token_to_str:N #1~failed}

% Use these name in the patching code (LaTeX2e syntax)

\cs_new_eq:NN \msg@error@nnn  \msg_error:nnn
\cs_new_eq:NN \msg@error@nnnn \msg_error:nnnn


% Variables for a new mark ⟨name⟩ :
% \c__extramarks_⟨name⟩_int : the mark (number as a char)
% \g__extramarks_topmark_⟨name⟩_tl : topmark (braced)
% \g__extramarks_firstmark_⟨name⟩_tl : firstmark (braced)
% \g__extramarks_botmark_⟨name⟩_tl : botmark (braced)

% commands for a new mark ⟨name⟩ :
% \extramarksput {⟨name⟩} {value} : command to set the mark
%
% \extramarkstop{⟨name⟩} : topmark (user level)
% \extramarksfirst{⟨name⟩} : firstmark (user level)
% \extramarkslast{⟨name⟩} : botmark (user level)

% Create a new mark; parameter is a name, preferably alphabetical

\NewDocumentCommand \extramarksnewmark { m }
{
  % Test if mark not yet defined
  \cs_if_exist:cTF {c__extramarks_#1_int}
    { \msg_error:nnnn {extramarks2} {already-defined}
      {\extramarksnewmark} {#1} }
    {
      % Create the mark
      \exp_args:Nc \newmarks {c__extramarks_#1_int}

      % Put it in the list of marks
      \seq_put_right:Nn \g__extramarks_marks_seq { #1 }

      % Create variables
      \tl_new:c {g__extramarks_topmark_#1_tl}      % topmark (braced)
      \tl_new:c {g__extramarks_firstmark_#1_tl}    % firstmark (braced)
      \tl_new:c {g__extramarks_botmark_#1_tl}      % botmark (braced)
      \tl_gset:cn {g__extramarks_topmark_#1_tl} {{}} % initialize topmark to empty mark (braced)
    }
}

% Algorithm for extracting the marks from a sequence of boxes on a page:
% for example in \twocolumn, or multicol, on each column.
% In the 'normal' case, on the main vertical box (\@outputbox)
%
% For each mark:
% INIT:
%     topmark <- previous botmark (initial: {{}})
%     botmark <- firstmark <- empty
% For each box:
%     (If the box was the result of a \vsplit skip this:)
%     \vsplit box to maxdimen
%     if splitfirstmark not empty: (i.e. there are marks in the box)
%         if firstmark = empty:
%             firstmark <- splitfirstmark
%         botmark <- splitbotmark
% END:
%     if firstmark = empty:
%         firstmark <- botmark <- topmark

% INIT code will be run at the creation of a mark,
% and after a page has been output. (I.e. at the beginning of each page)
%
% END code will be run just before a page is output.
%
% INIT code
%     topmark <- previous botmark
%     botmark <- firstmark <- empty

\cs_new_protected:Npn \__extramarks_get_boxmarks_init:n #1 % #1 = marks class
{
  \tl_gset_eq:cc { g__extramarks_topmark_#1_tl } { g__extramarks_botmark_#1_tl }
  \tl_gset_eq:cN { g__extramarks_firstmark_#1_tl } \c_empty_tl
  \tl_gset_eq:cN { g__extramarks_botmark_#1_tl } \c_empty_tl
}

% Extract the marks of the last vsplitted box.

\cs_new_protected:Npn \__extramarks_get_boxmarks:n #1 % #1 = marks class
{
  \tl_gset:No \l__extramarks_temp_tl
    { \splitfirstmarks \use:c{c__extramarks_#1_int} }
  \tl_if_empty:NF \l__extramarks_temp_tl
    % If not empty
    {
      \tl_if_empty:cT { g__extramarks_firstmark_#1_tl }
        {
          \tl_gset_eq:cN { g__extramarks_firstmark_#1_tl } \l__extramarks_temp_tl
        }
      \tl_gset:co { g__extramarks_botmark_#1_tl }
        { \splitbotmarks \use:c{c__extramarks_#1_int} }
    }
}

% END code
%     if firstmark = empty:
%         firstmark <- botmark <- topmark

\cs_new_protected:Npn \__extramarks_get_boxmarks_end:n #1 % #1 = marks class
{
  \tl_if_empty:cT { g__extramarks_firstmark_#1_tl }
  {
    \tl_gset_eq:cc { g__extramarks_firstmark_#1_tl } { g__extramarks_topmark_#1_tl }
    \tl_gset_eq:cc { g__extramarks_botmark_#1_tl } { g__extramarks_topmark_#1_tl }
  }
}

% Temporary \vsplit a box

\cs_new_protected:Npn \__extramarks_vsplit_box #1
{
    \dim_set:Nn \tex_splitmaxdepth:D \c_max_dim
    \int_set:Nn \tex_vbadness:D      \c_max_int
    % Make a temp copy of the box
    \vbox_set:Nn \l__extramarks_temp_box { \unvcopy #1 \unskip }
    % `Split' the box (but no split)
    \vbox_set_split_to_ht:NNn \l__extramarks_temp_box \l__extramarks_temp_box \c_max_dim
}

% Patching the output routine:
%
% The patching must be done with \ExplSyntaxOff, because otherwise it
% may fail if the macro to be patched contains _ : or significant
% spaces. Therefore also the names of these macros are with @ instead of
% _ and :

\cs_new_protected:Npn \extramarks@set@firstcolmarks
{
  \seq_map_inline:Nn \g__extramarks_marks_seq
    {
      % Process any marks in the box
      \__extramarks_get_boxmarks:n { ##1 }
    }
}

% Patch the processing of \twocolumn processing of optional argument

\cs_new_protected:Npn \extramarks@set@marks@topnewpage #1
{
  \group_begin:
    \global\setbox\@currbox\vbox{
        \hsize\textwidth
        \@parboxrestore
        \col@number \@ne
        #1
        \vskip -\dbltextfloatsep
             }
    \__extramarks_vsplit_box \@currbox
    \seq_map_inline:Nn \g__extramarks_marks_seq
      {
        % Process any marks in the box
        \__extramarks_get_boxmarks:n { ##1 }
      }
    \global \setbox\@currbox
    \color@vbox
      \normalcolor
      \copy\@currbox
    \color@endbox
  \group_end:
}

\cs_new_protected:Npn \extramarks@set@marks@outputbox
{
  \group_begin:
    \__extramarks_vsplit_box \@outputbox
    \seq_map_inline:Nn \g__extramarks_marks_seq
      {
        % Process any marks in the box
        \__extramarks_get_boxmarks:n { ##1 }

        % END:
        \__extramarks_get_boxmarks_end:n { ##1 }
      }
  \group_end:
}

\cs_new_protected:Npn \extramarks@init@marks
{
  \seq_map_inline:Nn \g__extramarks_marks_seq
  {
    % INIT:
    \__extramarks_get_boxmarks_init:n { ##1 }
  }
}

\ExplSyntaxOff

% Patch the processing of \twocolumn optional argument

\patchcmd{\@topnewpage}{\global \setbox\@currbox
    \color@vbox
      \normalcolor
      \vbox {%
        \hsize\textwidth
        \@parboxrestore
        \col@number \@ne
        #1%
        \vskip -\dbltextfloatsep
             }%
    \color@endbox}
  {\extramarks@set@marks@topnewpage{#1}}
  {}
  {\msg@error@nnn {extramarks2} {cannot-patch} {@topnewpage}}

% Patch the \@outputdblcol macro for the first colum case
% \@outputbox contains the first column, and has been \vsplit
% so we can get its marks with \splitmarks

\patchcmd{\@outputdblcol}{\ifx\@firstcolfirstmark\@empty}
  {\extramarks@set@firstcolmarks \ifx\@firstcolfirstmark\@empty}
  {}
  {\msg@error@nnn {extramarks2} {cannot-patch} {\@outputdblcol patch 1}}

% Patch the \@outputdblcol macro for the second column case
% \@outputbox contains the second column, not yet \vsplitted.
% Get the marks by \vsplit to the maximum height.

\patchcmd{\@outputdblcol}{\global\@firstcolumntrue}
  {\global\@firstcolumntrue\extramarks@set@marks@outputbox}
  {}
  {\msg@error@nnn {extramarks2} {cannot-patch} {\@outputdblcol patch 2}}

\patchcmd{\@outputdblcol}{\@outputpage}
  {\@outputpage\extramarks@init@marks}
  {}
  {\msg@error@nnn {extramarks2} {cannot-patch} {\@outputdblcol patch 3}}

% End of \@outputdblcol patching code

% Patch the \@outputpage macro for the single column case

\patchcmd {\@opcol} {\@outputpage}
  {\extramarks@set@marks@outputbox \@outputpage \extramarks@init@marks}
  {}
  {\msg@error@nnn {extramarks2} {cannot-patch} {in \@opcol: \@outputpage} {}}

\ExplSyntaxOn

% End of \@outputpage patching code

\extramarksnewmark{left}
\extramarksnewmark{right}

% Put extra pair of braces around the marks, to distinguish
% an empty mark from the absence of a mark

\NewDocumentCommand \extramarksput { m m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Use protected eval
    \group_begin:
      \cs_set_eq:NN \label    \scan_stop:
      \cs_set_eq:NN \index    \scan_stop:
      \cs_set_eq:NN \glossary \scan_stop:
      \unrestored@protected@xdef \l__extramarks_temp_tl { #2 }
      % Put braced value in the mark
      \tex_marks:D \use:c{c__extramarks_#1_int} {{ \l__extramarks_temp_tl }}
      \endgroup
  }
  { \msg_error:nnnn {extramarks2} {not-defined} {\extramarksput} {#1} }
}

\NewDocumentCommand \extramarkstop { m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Get unbraced value out of the mark
     \tl_head:v { g__extramarks_topmark_#1_tl }
  }
  { \msg_error:nnnn {extramarks2} {not-defined} {\extramarkstop} {#1} }
}

\NewDocumentCommand \extramarksfirst { m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Get unbraced value out of the mark
     \tl_head:v { g__extramarks_firstmark_#1_tl }
  }
  { \msg_error:nnnn {extramarks2} {not-defined} {\extramarksfirst} {#1} }
}

\NewDocumentCommand \extramarkslast { m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Get unbraced value out of the mark
     \tl_head:v { g__extramarks_botmark_#1_tl }
  }
  { \msg_error:nnnn {extramarks2} {not-defined} {\extramarkslast} {#1} }
}

% Convenience functions

\NewDocumentCommand \extramarksleft { m }
{
  \extramarksput{left}{#1}
}

\NewDocumentCommand \extramarksright { m }
{
  \extramarksput{right}{#1}
}

\NewDocumentCommand \extramarks { m m }
{
  \extramarksput{left}{#1}
  \extramarksput{right}{#2}
}

% Extramarks compatibility commands

\NewDocumentCommand\firstleftxmark  { } {\extramarksfirst {left}  }
\NewDocumentCommand\firstrightxmark { } {\extramarksfirst {right} }
\NewDocumentCommand\topleftxmark    { } {\extramarkstop   {left}  }
\NewDocumentCommand\toprightxmark   { } {\extramarkstop   {right} }
\NewDocumentCommand\lastleftxmark   { } {\extramarkslast  {left}  }
\NewDocumentCommand\lastrightxmark  { } {\extramarkslast  {right} }

\cs_new_eq:NN \firstxmark \firstleftxmark
\cs_new_eq:NN \lastxmark \lastrightxmark
\cs_new_eq:NN \topxmark \topleftxmark

\cs_new_eq:NN \firstrightmark \rightmark
\cs_new_eq:NN \lastleftmark \leftmark

\NewDocumentCommand\firstleftmark { }
  {\expandafter\@leftmark\firstmark\@empty\@empty}
\NewDocumentCommand\lastrightmark { }
  {\expandafter\@rightmark\botmark\@empty\@empty}

% We check the presence of the multicol package in the 'begindocument'
% hook, because that's the only place where we can be sure, and is still
% early enough. However, we can't code patching code directly inside the
% hook, because that won't work. So we input a file with the code. That
% has the additional advantage that we don't load the code when it isn't needed.
% But as we use `\input` we have to put it in \makeatletter/\makeatother.

\AddToHook{begindocument}{
  \@ifpackageloaded{multicol}
  {
    \input{extramarks2-multicol.tex}
  }
  { }
}

\ExplSyntaxOff

% \endinput
%%
%% End of file `extramarks2.sty'.
