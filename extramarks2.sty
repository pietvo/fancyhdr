%%
%% This is file `extramarks2.sty',
%%
%% This file may be distributed and/or modified under the conditions of
%% the LaTeX Project Public License, either version 1.3 of this license
%% or (at your option) any later version.  The latest version of this
%% license is in:
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% and version 1.3 or later is part of all distributions of LaTeX version
%% 2005/12/01 or later.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{extramarks2}
           [2021/03/07 v0.1
                  Extra marks for LaTeX]
% Copyright (C) 2021 by Pieter van Oostrum <pieter@vanoostrum.org>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\RequirePackage{expl3,xparse}
\RequirePackage{etoolbox}

\ExplSyntaxOn

% Pick up traditional macros

\cs_new_eq:NN \__extramarks_newmarks:N \newmarks
\cs_generate_variant:Nn \__extramarks_newmarks:N { c }

% Global variables
% Sequence of define extra marks

\seq_new:N \g__extramarks_marks_seq

% Temporary box

\box_new:N \l__extramarks__temp_box

% Temporary token lists

\tl_new:N \l__extramarks_temp_tl

% Messages
% 
\msg_new:nnn {extramarks} {not-defined} {\token_to_str:N #1:~mark~#2~not~defined}
\msg_new:nnn {extramarks} {already-defined} {\token_to_str:N #1:~mark~#2~already~defined}
\msg_new:nnn {extramarks} {cannot-patch} {Cannot patch \token_to_str:N #1}

% Variables for a new mark ⟨name⟩ :
% \c__extramarks_⟨name⟩_int : the mark (number as a char)
% \g__extramarks_previousmark_⟨name⟩_tl : last mark of previous page (braced)
% \g__extramarks_topmark_⟨name⟩_tl : topmark (braced)
% \g__extramarks_firstmark_⟨name⟩_tl : firstmark (braced)
% \g__extramarks_botmark_⟨name⟩_tl : botmark (braced)

% commands for a new mark ⟨name⟩ :
% \extramarksput {⟨name⟩} {value} : command to set the mark
%
% \extramarkstop{⟨name⟩} : topmark (user level)
% \extramarksfirst{⟨name⟩} : firstmark (user level)
% \extramarkslast{⟨name⟩} : botmark (user level)

% Create a new mark; parameter is a name, preferably alphabetical

\NewDocumentCommand \extramarksnewmark { m }
{
  % Test if not yet defined
  \cs_if_exist:cTF {c__extramarks_#1_int}
    { \msg_error:nnnn {extramarks} {already-defined}
      {\extramarksnewmark} {#1} }
    {
      % Create the mark
      \__extramarks_newmarks:c {c__extramarks_#1_int}

      % Put it in the list of marks
      \seq_put_right:Nn \g__extramarks_marks_seq { #1 }

      % Create variables
      \tl_new:c {g__extramarks_topmark_#1_tl}      % topmark (braced)
      \tl_new:c {g__extramarks_firstmark_#1_tl}    % firstmark (braced)
      \tl_new:c {g__extramarks_botmark_#1_tl}      % botmark (braced)
      \tl_gset:cn {g__extramarks_botmark_#1_tl} {{}}   % initialize to empty for next topmark
    }
}

% Algorithm for extracting the marks from a sequence of boxes:
% For each mark:
% INIT:
%     topmark <- previous botmark
%     firstmark <- empty
% For each box:
%     (If the box was the result of a \vsplit skip this:)
%     \vsplit box to maxdimen
%     if splitfirstmark not empty:
%         if firstmark = empty:
%             firstmark <- splitfirstmark
%             botmark <- splitbotmark
% END:
%     if firstmark = empty:
%         firstmark <- botmark <- topmark

% Patch the \@outputdblcol macro for the \twocolumn case
% \@outputbox contains the first column, and has been \vsplit
% so we can get its marks with \splitmarks

% INIT code
%     topmark <- previous botmark
%     firstmark <- empty

\cs_new_protected:Npn \__extramarks_get_boxmarks_init:n #1 % #1 = marks class
{
  \tl_set_eq:Nc \l__extramarks_temp_tl { g__extramarks_botmark_#1_tl }
  \tl_gset_eq:cN { g__extramarks_topmark_#1_tl } \l__extramarks_temp_tl
  \tl_gset_eq:cN { g__extramarks_firstmark_#1_tl } \c_empty_tl
}

% Extract the marks of the last vsplitted box.

\cs_new_protected:Npn \__extramarks_get_boxmarks:n #1 % #1 = marks class
{
  \tl_gset:No \l__extramarks_temp_tl
    { \splitfirstmarks \use:c{c__extramarks_#1_int} }
  \tl_if_empty:NF \l__extramarks_temp_tl
    % If not empty
    {
      \tl_if_empty:cT { g__extramarks_firstmark_#1_tl }
        {
          \tl_gset_eq:cN { g__extramarks_firstmark_#1_tl } \l__extramarks_temp_tl
        }
      \tl_gset:co { g__extramarks_botmark_#1_tl }
        { \splitbotmarks \use:c{c__extramarks_#1_int} }
    }
}

% END code
%     if firstmark = empty:
%         firstmark <- botmark <- topmark

\cs_new_protected:Npn \__extramarks_get_boxmarks_end:n #1 % #1 = marks class
{
  \tl_if_empty:cT { g__extramarks_firstmark_#1_tl }
  {
    \tl_gset_eq:cc { g__extramarks_firstmark_#1_tl } { g__extramarks_topmark_#1_tl }
    \tl_gset_eq:cc { g__extramarks_botmark_#1_tl } { g__extramarks_topmark_#1_tl }
  }
}

\cs_new_protected:Nn \__extramarks_setfirstcolmarks:
{
  \seq_map_inline:Nn \g__extramarks_marks_seq
    {
      % INIT:
      \__extramarks_get_boxmarks_init:n { ##1 }

      % Process any marks in the box
      \__extramarks_get_boxmarks:n { ##1 }
    }
}

\patchcmd{\@outputdblcol}{\ifx\@firstcolfirstmark\@empty}
  {\__extramarks_setfirstcolmarks:\ifx\@firstcolfirstmark\@empty}
  { }
  { \msg_error:nnn {extramarks} {cannot-patch} {\@outputdblcol~patch~1} }

% Patch the \@outputdblcol macro for the second column case
% \@outputbox contains the second column, not yet \vsplitted.
% Get the marks by \vsplit to the maximum height.

\cs_new_protected:Nn \__extramarks_setsecondcolmarks:
{
  \group_begin:
    \dim_set:Nn \tex_splitmaxdepth:D \c_max_dim
    \int_set:Nn \tex_vbadness:D      \c_max_int
    % Make a temp copy of \@outputbox
    \vbox_set:Nn \l__extramarks__temp_box { \unvcopy\@outputbox\unskip }
    % `Split' the box (but no split)
    \vbox_set_split_to_ht:NNn \l__extramarks__temp_box \l__extramarks__temp_box \c_max_dim
    \seq_map_inline:Nn \g__extramarks_marks_seq
      {
        % Process any marks in the box
        \__extramarks_get_boxmarks:n { ##1 }

        % END:
        \__extramarks_get_boxmarks_end:n { ##1 }
      }
  \group_end:
}

\patchcmd{\@outputdblcol}{\global\@firstcolumntrue}
  {\global\@firstcolumntrue\__extramarks_setsecondcolmarks:}
  { }
  { \msg_error:nnn {extramarks} {cannot-patch} {\@outputdblcol~patch~2} }

% End of \@outputdblcol patching code

% Patch the \@outputpage macro for the single column case

\cs_new_protected:Nn \__extramarks_setmarks:
{
  \group_begin:
    \dim_set:Nn \tex_splitmaxdepth:D \c_max_dim
    \int_set:Nn \tex_vbadness:D      \c_max_int
    % Make a temp copy of \@outputbox
    \vbox_set:Nn \l__extramarks__temp_box { \unvcopy\@outputbox\unskip }
    % `Split' the box (but no split)
    \vbox_set_split_to_ht:NNn \l__extramarks__temp_box \l__extramarks__temp_box \c_max_dim
    \seq_map_inline:Nn \g__extramarks_marks_seq
      {
        % INIT:
        \__extramarks_get_boxmarks_init:n { ##1 }
    
        % Process any marks in the box
        \__extramarks_get_boxmarks:n { ##1 }

        % END:
        \__extramarks_get_boxmarks_end:n { ##1 }
      }
  \group_end:
}

\patchcmd { \@opcol } { \@outputpage }
  { \__extramarks_setmarks: \@outputpage }
  { }
  { \msg_error:nnn {extramarks} {cannot-patch} {\@outputpage} {} }


% End of \@outputpage patching code

\extramarksnewmark{left}
\extramarksnewmark{right}

% Put extra pair of braces around the marks, to distinguish
% an empty mark from the absence of a mark

\NewDocumentCommand \extramarksput { m m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Use protected eval
    \group_begin:
      \cs_set_eq:NN \label    \scan_stop:
      \cs_set_eq:NN \index    \scan_stop:
      \cs_set_eq:NN \glossary \scan_stop:
      \unrestored@protected@xdef \l__extramarks_temp_tl { #2 }
      % Put braced value in the mark
      \tex_marks:D \use:c{c__extramarks_#1_int} {{ \l__extramarks_temp_tl }}
      \endgroup
  }
  { \msg_error:nnnn {extramarks} {not-defined} {\extramarksput} {#1} }
}

\NewDocumentCommand \extramarkstop { m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Get unbraced value out of the mark
     \tl_head:v { g__extramarks_topmark_#1_tl }
  }
  { \msg_error:nnnn {extramarks} {not-defined} {\extramarkstop} {#1} }
}

\NewDocumentCommand \extramarksfirst { m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Get unbraced value out of the mark
     \tl_head:v { g__extramarks_firstmark_#1_tl }
  }
  { \msg_error:nnnn {extramarks} {not-defined} {\extramarksfirst} {#1} }
}

\NewDocumentCommand \extramarkslast { m }
{
  \cs_if_exist:cTF {c__extramarks_#1_int}
  {
    % Get unbraced value out of the mark
     \tl_head:v { g__extramarks_botmark_#1_tl }
  }
  { \msg_error:nnnn {extramarks} {not-defined} {\extramarkslast} {#1} }
}

% Convenience functions

\NewDocumentCommand \extramarksleft { m }
{
  \extramarksput{left}{#1}
}

\NewDocumentCommand \extramarksright { m }
{
  \extramarksput{right}{#1}
}

\NewDocumentCommand \extramarks { m m }
{
  \extramarksput{left}{#1}
  \extramarksput{right}{#2}
}

\NewDocumentCommand\firstleftxmark  { } {\extramarksfirst {left}  }
\NewDocumentCommand\firstrightxmark { } {\extramarksfirst {right} }
\NewDocumentCommand\topleftxmark    { } {\extramarkstop   {left}  }
\NewDocumentCommand\toprightxmark   { } {\extramarkstop   {right} }
\NewDocumentCommand\lastleftxmark   { } {\extramarkslast  {left}  }
\NewDocumentCommand\lastrightxmark  { } {\extramarkslast  {right} }

\cs_new_eq:NN \firstxmark \firstleftxmark
\cs_new_eq:NN \lastxmark \lastrightxmark
\cs_new_eq:NN \topxmark \topleftxmark

\cs_new_eq:NN \firstrightmark \rightmark
\cs_new_eq:NN \lastleftmark \leftmark

\AddToHook{begindocument}{
  \@ifpackageloaded{multicol}
  {
    \RequirePackage{extramarks2-multicol}
  }
  { }
}

\ExplSyntaxOff

% \endinput
%%
%% End of file `extramarks2.sty'.
